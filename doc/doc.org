#+title: Инженеры будущего
#+subtitle: Rescue line
#+AUTHOR: Андрей Люнгрин
#+AUTHOR: Иван Наумов
#+DATE: 11 Мая 2022
#+latex_header_extra: \include{preamble.tex}

* Введение
Наша работа представляет из себя исследовательский проект проводимый в рамках соревнований под регламентов =RoboCup Junior RescueLine=. В рамках данной работы нами было разработано несколько прототипов роботизированных систем о которых пойдёт речь далее.
* Команда
** Андрей Люнгрин
 #+attr_latex: :width 100
[[./images/andrey.jpeg]]
- Капитан команды
- Обязанности:
  - Консультация по вопросам конструкции
  - Производство некоторых деталей
  - Финальная сборка и тестирование конструкции
  - Проектирование концепта
  - Разработка программных компонентов низкого уровня для управления приводами
  - Разработка программных компонентов для обеспечения связи между системами управления приводами и принятия решений
  - Разработка программной системы принятия решений
  - Сборка электронной составляющей робота
  - И просто хороший человек
\pagebreak
** Иван Наумов
#+attr_latex: :width 100
[[./images/ivan.jpg]]
- Инженер-конструктор
- Обязанности:
  - Проектирование концепта
  - Моделирование конструкции робота в САПР
  - Производство основных деталей конструкци
  - Сборка конструкции
* Механическая часть
Основными целями при проектированнии конструкции были простоата и удобство обслуживания, и все последующие технические решения были направлены на улучшение этих двух метрик.

Все узлы робота были произведены с исопльзованием трёхмерной печати
** Колёсная платформа
Конструктивно, робот представляет их себя четырёхколёсную тележку с двумя ведущими и двумя опорными колёмами. Опорные колеса были модифицированы так, чтобы максимально уменьшить сцепление с поверхностью. Это необходимо для того, чтобы кинематическая схема робота была приближена к таковой у двухколесного робота. Плюс такой схемы заключается в том, что ось поворота робота более предсказуема, и в меньшей степени зависит от распределения массы.

Каждое колесо имеет две точки опоры, что позволяет снизить изламывающие нагрузки на ось колеса, что увеличивает надёжность конструкции, а также делает положение колеса относительно рамы робота более предсказуемым.
\pagebreak
** Система захвата
Для захвата и сброса шариков и других игровых предметов, используется двух-осевой манипулятор. Первая ось обеспечивет подъём за счёт поворота всей сборки захвата. Вторая ось является клешнёй, которая выполняет захват объекта. Основное достоинство такой конструкции - её просто. Из недостатков, можно отметить её низкую точность позиционирования, и необходимость приложения высокого усилия мотором подъёма.
** Крепление электроники
Вся электронника робота закреплена на одной съёмной пластине, расположенной перпендикулярно плоскости рамы. Две основных платы раположены с разных сторон пластины. Такая конфигурация обеспечивает полный доступ ко всем элементам системы, а также позволяет быстро их демонтировать для замены или другого обслуживания.
* Электронная часть
Наша система состоит из трёх основных узлов:
1. Узел питания
   - Распределяет питание из одного источника между всеми потребителями
   - Согласовывает питающие уровни
   - Состоит из:
     - Высокотоковый литий-полимерный аккумулятор на 12V
     - Понижающий преобразователь
     - Соединительные колодки =Wago=
2. Узел принятия решений
   - Получает и обрабатывает информацию об окружающем мире
   - Состоит из:
     - Одноплатный компьютер: =Raspberry Pi 3B=
     - Основная передняя камера, для следования по линии: =Pi Camera=
     - Задняя камера для захвата предметов
3. Исполнительный узел
   - Управляет шаговыми двигателями в ответ на команды с Узла принятия решений
   - Состоит из:
     - Микроконтроллер на отладочной плате: =STN32 Nucleo-F401RE=
     - Материнская плата драйверов ШД: =Arduino CNC shield v3=
     - Четыре драйвера ШД: =StepStick A4988=
     - Два приводных шаговых двигателя
     - Два шаговых двигателя для манипулятора

Шаговые двигатели для привода были использованы потому, что такой тип двигателя позволяет просто контроллировать их скорость, также тем, что существует множество готовых аппаратных решений для их управления. Простота управления и цена - вероятно единственные приимещества шаговых двигателей. К их недостаткам относятся: низкий КПД, низкое соотношение крутящего к массе двигателя, сильные вибрации. К счастью, все эти приблемы не значительны в нашем случае (нету ограничения по весу, низкие требования к тяге и времени автономной работы, а критерий простоты управления хорошо соотносится с целями проекта.

Решение использовать отдельный контроллер для управления двигателями были обосновано тем, что реализовать генерацию управляющих пульсов для драйверов ШД с микросекундной точностью, проще на системе реального времени, работая на низком уровне. Однако, такой подход влечет за собой усложнение системы, из-за необходимости обеспечивать связь между двумя контроллерами. В будущем, второй контроллер может быть упразднён.

#+attr_latex: :width 100
#+BEGIN_SRC dot :file images/electronics-diag.png :cmdline -Kdot -Tpng
digraph {
    graph [ranksep=1, nodesep=1, compound=true]
    node [shape=box]

    bat [label="Аккумулятор (12V)"]
    buck_conv [label="Понижающий преобразователь"]

    {
        rank=same
        mcu [label="Микроконтроллер"]
        sbc [label="Одноплатный компьютер"]
    }

    {
        rank=same
        front_camera [label="Передння камера"]
        rear_camera [label="Задняя камера"]
    }

    {
        rank=same
        drivers_mb [label="Материнская плата\nдрайверов ШД"]
        stepper_dirvers [label="Драйвера ШД (x4)"]
    }
    steppers [label="Шаговые двигатели (x4)"]

    limit_sws [label="Концевики (x2)"]

    bat -> {buck_conv, drivers_mb} [color=red]
    buck_conv -> {mcu, sbc} [color=orange]

    sbc -> front_camera [label="CSI"]
    sbc -> rear_camera [label="USB"]
    mcu -> drivers_mb
    mcu -> sbc [dir=both, label="USB"]

    drivers_mb -> {stepper_dirvers, limit_sws}
    {
        edge [color=red]
        drivers_mb -> stepper_dirvers
        stepper_dirvers -> steppers
    }
    graph [
        labelloc="b" labeljust="r" label= <
        <font color="red">12V</font>
        <font color="orange">5V</font>
        <font color="black">logic</font>
        >
  ]
}
#+END_SRC

#+RESULTS:
[[file:images/electronics-diag.png]]
* Программная часть
** Контроллер двигателей
Программа для микроконтраллера была написана на =Rust= с использованием фреймворка =RTIC=. =Rust= - компилируемый, статически типизированный язык программирования среднего уровня, основной особенностью которого является гарантия безопасности управления памяти на этапе компиляции. =RTIC= - Real Time Interrupt-driven Concurency - библиотека реализующая конкурентность, удобный интерфейс для управления общими ресурсами, а также гарантию отсутствия взаимных блокировок на этапе компиляции.

Генерация управляющего сигнала для драйверов ШД реализована с исопльзованием планировщика задач =RTIC=. Структура, представляющая шаговый двигатель, предоставляет метод =update=, который обновляет внутреннее состояние структуры, и может обновить уровень на выходе контроллера. Метод возвращает время, через которое он должен быть вызван в следующий раз. Внутреннее состояние контроллера ШД представляет из себя машину состояний, которая описывается следующим образом:
#+begin_src rust
state_machine! {
    Idle(Start) => StartStepHigh, // Состояние_1(Событие) => Состояние_2

    StartStepHigh(PulseStart) => StepHigh,
    StepHigh(PulseEnd) => StartStepLow,

    StartStepLow(PulseStart) => StepLow,
    StepLow(PulseEnd) => StartStepHigh,

    Idle(Stop) => Idle,
    StartStepHigh(Stop) => Idle,
    StepHigh(Stop) => StartStepLow [Stop],
    StartStepLow(Stop) => Idle,
    StepLow(Stop) => Idle,
}
#+end_src

Сам метод выглядит следующим образом:
#+begin_src rust
pub fn update(&mut self) -> Option<MicrosDurationU32> {
    if self.step_delay.is_none() {
        return None;
    }

    match *self.state_machine.state() {
        StepperStateState::Idle => { None }
        StepperStateState::StartStepHigh => {
            self.step.set_high().ok();
            self.state_machine.consume(
                        &StepperStateInput::PulseStart).unwrap();

            Some(self.pulse_width)
        },
        StepperStateState::StartStepLow => {
            self.step.set_low().ok();
            self.state_machine.consume(
                        &StepperStateInput::PulseStart).unwrap();

            Some(self.step_delay.unwrap())
        },
        StepperStateState::StepHigh | StepperStateState::StepLow => {
            self.state_machine.consume(
                        &StepperStateInput::PulseEnd).unwrap();

            self.update()
        }
    }
}
#+end_src

Такой дизайн обусловлен тем, что, этот метод вызывается часто (до 5кГц), и имеет приоритет выше других задач, т.е. может прервать их выполнение. Проблема становится более заметной, если учесть, что одновременно могут работать до четырёх двигателей.

Использование этого модуля в программе выгладит так:
#+begin_src rust
#[init]
fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
    let rcc = ctx.device.RCC.constrain();
    let clocks = rcc.cfgr.sysclk(84.mhz()).freeze();
    let mut syscfg = ctx.device.SYSCFG.constrain();

    let gpiob = ctx.device.GPIOB.split();

    let right_stepper = {
        let (step, dir) = (gpiob.pb3.into_push_pull_output(),
                           gpiob.pb10.into_push_pull_output());
        let mut stepper = Stepper::new(step, dir,
                                       || right::spawn().unwrap());
        stepper.set_direciton(StepperDireciton::CounterClockwise);
        stepper.set_speed(100_u32.Hz());
        stepper
    };

    (
        Shared { right_stepper },
        Local { },
        init::Monotonics(mono)
    )
}

#[task(shared = [right_stepper], priority = 15)]
fn right(mut cx: right::Context) {
    cx.shared.right_stepper.lock(|stepper| {
        let next_delay = stepper.update();
        if let Some(next_delay) = next_delay {
            right::spawn_after(next_delay).ok();
        }
    });
}
#+end_src
** Протокол взаимодействия
